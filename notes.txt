SIC NOTES
------------


ARITHMETIC OPERATORS:
+ - * // / % **

All operators are binary operators. They need 2 operands/values/input
The rule/syntax says we must place the operator in between the operands which is INFIX notation.
The I/P are numbers.
The O/P is number.
The operators + and - have the least precedence (heirarchy/preference)
All the Arithmetic operators except the power operator have Left to Right Associtivity.
x + y + z
4 + 5 - 19
Here, the expression 4 + 5 is evaluated 1st
2 ** 3 ** 2
Here 3 ** 2 is evaluated 1st.
NOTE:
The way +ve integers are stored in memory, the way -ve integers are stored in memory and the floating point numbers (number with precission) are all different.

num = 67
Here 67 is just converted to binary sna stored. Also note that the number 67 here is Decimal number.
num = 0o67
Here the number is Octal
num = 0b101010
Here the number is binary
num = 0x99
num = 0X99
num = 0X7F
Here all the 3 examples are of Hexa-Decimal numbers
f   hexa-decimal
17  octal
15  decimal
1111 binary
ff = 15 * 16(1) + 15 * 16(0) = 240 + 15 = 255
11111111
ffff = 65535
In a particular case, 11111111 is not 255. When is it ?
So in signed byte, the max value and minimum values (respectively) are:"
01111111 = 127
10000000 = -128

num = -23
-23
23
00010111
11101000
11101001
-1 * 2(7) + 1 * 2(6) + 1 * 2(5) + 9
-128 + 64 + 32 + 9
-64 + 41
= -23

floating point numbers are stored using IEEE standards.

5 + 6
0101
0110
1011

5 + 6.055
5.0 + 6.055

4 - 5 % 7
4 + 8 + 9
Here the expressions are read from L -> R
But they are evaluated only after converting user given infix notation expression into postfix expression.

RELATIONAL OPERATORS:
> < >= <= != ==

All are binary.
I/P are numbers
O/P is boolean
Used wih infix notation.
Have higher precedence than logical operators but lesser than Arithmetic.

for i from 1 to N do
for i = 1; i <= N; i++:
for i = 1; i < N+1; i++:

for i = 1; i <= 20; i++
for i = 1;  i < 21; i++

[10, 20] Closed Interval
i >= 10 and i <= 20
[10, 20)
i >= 10 and i < 20
(20, 50)
---------------------------------------------------
LOGICAL OPERATORS:
& && | || ! (C/C++/Java/C# etc)

and or not !  (Python)

I/P are boolean
O/P is boolean

a = b
variable = value
-----------------------------------
Important points while implementing a solution:
1. Time efficiency
2. Space efficiency
3. Simplicity/Readability
4. Maintainability
-------------------------------------------
HOW TO SOLVE A PROBLEM:

1. Read the problem statement carefully. List down the I/P data, relavant information. Isolate the unwanted information. Assertain what is the O/P.
Outcome: I/P we know, O/P we know

2. Find the solution. Forget programming. Find the solution using any specific technique or using some formula or trial and error method.
Outcome: We know the solution

3. Write the Algorithm. Step by step procedure. Each step must be simple, unambigious and finite.

4. Write the Fake-code (Pseucode)

5. Code it!

6. Unit testing, Cyxclomatic complexity (to find number of paths in the logic), optimize the logic.

i/p: non negative number. 
math.sqrt we need to use
o/p: print PS or Not

45      6.8     6   36
144     12.0    12  144

Read a non-ve number, say N
find root of N, say ROOT
convert ROOT to integer
check if ROOT * ROOT is N
if yes, print N is Perfect Square
else, print N is not a P S

N = input()
ROOT = square_root(N)
ROOT = integer(ROOT)
if ROOT * ROOT is equal to N, then
    print N is a P S
else
    print N is not a P S
    



Input():Functions from the core python library which gives the input altrnally as a string which gives the output for the required input
List: it is a collections of items where items refer to the data where all the items are stored in the contigious memory location. That is if you any 2 consecutive elements, then there is no gap in between them.
Lists in python need not to be of the same types as in the case of C/C++/Java etc.


print(my_function(None, 20))
print(my_function(None, None))
print(my_function(20, None))
my_function(10, 20)
my_function(10)
my_function()
my_function(num1 = 25)
my_function(None, 20)
my_function(num2 = 25)
my_function(num2 = 25, num1 = 99)
my_function(num1 = 25, num2 = 99)

--------------------------------------------------------------------
What is a DS?
int numbers[10]; // DS
int num1, num2, num3, num4, num5; // May or may not be a DS

The lookup (accessing any element in the array/list) is one unit time.
Thus the efficiency of accessing an element in the array is O(1)
Usually size of an array is fixed. Because of which there are almost always chances of either wastage of memory or shortage of memory.
Thus, an array is time efficient DS but memory inefficienct DS.

Assume size value is given by user at runtime
float *numbers = new float[size];
float[] numbers = new float[size];

float numbers[20];

Good example of list/array:
To store names of girls of SIC training.
To store distances of the places to be visited in the order of places of the trip.
Not good examples of Array/List:
To store all the UPI transactions of a specific date in the entire country.

---------------------------------------------------------------------------------------
list is a class in python.
We create object(s) out of a class
When we say:
n = 10
Here n is just a number. Its value 10 has not units like cm, mts or mt/sec or Hz or mts/sec square
Now say, we have a course which has a minimum duration and a maximum duration.
engg_course_duration = 4
units = 'years'
minimum_duration = 4
maximum_duration = 8

class EngineeringCourseDuration:
    duration
    unit
    minimum_duration
    maximum_duration
    maximum_per_semester

    initialize_values()
    set_duration()
    get_duration()
    set_unit()
    get_unit()
    set_maximum_duration()

class Customer
    id
    name
    father_name
    phone_number
    email
    address
    adhaar
    pan

class Account
    id
    custmoer_id
    account_number
    account_type
    branch_id
    balance

    create()
    delete()
    freeze()
    modify()
    read_details()

class Transaction
    id
    datetime
    type
    account_id

    check_balance()
    deposit()
    withdraw()
    mini_stmt()
    change_pin()
    add_beneficiary()
    transfer()

Account* account = new Account(); // C++
Account account = new Account(); // Java
account = Account() // Python

class NRIAccount : public Account {
private:
    string passportNumber;
};

class NRIAccount extends Account {
    private String passportNumber;
}

class NRIAccount (Account):
    def __init__(self):
        passportNumber = ""

names1 = []
names2 = list()

names3 = ['suresh', 'mahesh', 'girish']
other_names = list(names3)


list methods:
    list()  # creating + initializing
    append()
    pop()
    insert()
    remove()
    sort()
    reverse()
    extend()




i++;
j--;
a[i] = b[j];
b[j]++;

a[++i] = b[--j]++;

Bubble Sort:
Its trivial (simpler, easier) and traditional way of sorting technique. Such kind of technique we call as BRUTE FORCE.

Compare consecutive elements of the array
Assuming we are sorting in increasing order, when the left element (element at lower index) is higher than the next element (right element) then we swap them.
By continuing this till end of un-sorted part of the array, we end up end pushing or bubbling the largest element in its final position.
Once the element is in its final position, we do not disturb it.
Thus it goes into the sorted part of the array.
Thus we must be able to imagine 2 arrays in the given array.

In Bubble sort, we do not check for anything like, if the array is some what or almost sorted. Nor we consider any element to be already in its final position.
We just start sorting (aaplying the logic).
Now, say if the given array is already fully sorted, yet, the Bubble sort algorithm has same number of comparisons when the array is not sorted.

For any sorting technique, the best case scenario is that the array is already sorted.
The worst case scenario is when the given array is already sorted, but we have to sort in reverse order.

In any sorting technique, we must reach/access every element from the unsorted array (given array). So the efficiency of this part of the sorting is O(n)
And we must also have a logic that puts every element in its right position in the array. Efficiency of this is O(n)

n-1  +  n-2  +  n-3  +  ..... 4 + 3 + 2 + 1
= n(n+1)/2
~ n2

Usually, in almost all sorting techniques, the outer loop accesses elements from the unsorted array.
The inner loop does some work such as comparison, shifting elements, finding position etc.

algorithm:
input: array
from 1st element till last in given array do:
    from 1st element till last element in unsorted part of given array do:
        compare consecutive elements:
        if left element is greater than right element then:
            swap the elements

Pseudocode:
Bubble_sort(ARRAY)
for i from 0 to n-2 do:
    for j from 0 to n-2-i do:
        if ARRAY[j] > ARRAY[j+1] then:
            swap: ARRAY[j] , ARRAY[j+1]

def bubble_sort(array)
    for i in range(len(array)-1):
        for j in range(len(array)-1-i):
            if array[j] > array[j+1]:
                array[j] , array[j+1] = array[j+1] , array[j]

WCE: O(n2)
BCE: O(n2)

45  32  23  50  1  11  99  50  30  55
32  23  45  1  11  50  50  30  55  99

1  3   5   8  19

def bubble_sort(array)
    for i in range(len(array)-1):
        sorted = True
        for j in range(len(array)-1-i):
            if array[j] > array[j+1]:
                array[j] , array[j+1] = array[j+1] , array[j]
                sorted = False
        if sorted:
            return

WCE: O(n2)
BCE: O(n)
-------------------------------------------------
Insertion Sort: Decrease and Conquer technique

45  32  23  50   1  11  99  50  30  55
32  45  
1   11  23  30  32  45  50  50  55  99


1   11  23  30  32  45  50  50  55  99
1   11  23  30  32  45  50  50

ele = 50

insertion_sort(ARRAY):
    for i from 1 to n-1 do:
        ele = ARRAY[i] # element to be inserted
        j = i-1 # index of last element in sorted array
        while j >= 0 and ele < ARRAY[j]: # until we reach index 0 or the position to insert new element into sorted array
            ARRAY[j+1] = ARRAY[j] # shift present element in sorted array to next position
            j-- # move back in the sorted array by one position
        ARRAY[j+1] = ele # place/insert the element in its right position
--------------------------------------------------
Logic/algorithm
Efficiencies
Category
Optimization
Application

---------------------------------------------------
45  82  23  50   1  11  99  70  30  55

pivot = ARRAY[0]
j = 1
for i from 1 to n-1 do:
    if pivot < ARRAY[i]
        swap ARRAY[i] with ARRAY[j]
        j++
swap ARRAY[j] with ARRAY[0]

def partition_array(my_list):
    pivot = my_list[0]
    for i in rabge(1, n):
        if pivot < my_list[i]
            my_list[i], my_list[j] = my_list[j], my_list[i]
            j += 1
    my_list[0], my_list[j] = my_list[j], my_list[0]

partition has O(n) efficiency
When partition partitions 2 equal halves then the quick_sort algorithm has O(LogN) efficiency

Thus, BCE of quick sort is O(N LogN)

In the worst case scenario the partition places the pivot element in such a position that there is always only left partitioned array or only right partitioned array. Thus making the quick_sort call the partition algorithm N times.
Thus WCE of quick sort is O(n2)
-----------------------------------------------------------------
MERGE SORT

45  82  23  50   1  11  99  70  30  55

45  82  23  50  1       11  99  70  30  55

45  82      23  50  1       11  99  70  30  55

45     82      23      50     1      11     99    70     30      55
i      j

45  82     23      50     1      11     99    70     30      55
                                                      i       j
k=30  55

45  82      23  50     1  11       70  99     30  55
                       i           j
k=1  11  70  99

23  45  50  82      1  11  70  99     30  55
i                    j

k= 
1  11  23  45  50  70  82  99        30  55
i                                    j
k=1  11  23  30  45  50  55  70  82  99

def merge_sort(array, low, high):
    if high > low:
        mid = (low + high) // 2
        merge_sort(array, low, mid)
        merge_sort(array, mid+1, high)
        array[low:high] = merge(array, low, mid, high)

def merge(array, low, mid, high):
    a1 = array[low:mid+1]
    a2 = array[mid+1:high+1]
    a3 = []
    i = low
    j = mid+1
    while i < len(a1) and j < len(a2):
        if a1[i] < a2[j]:
            a3.append(a1[i])
            i += 1
        else:
            a3.append(a2[j])
            j += 1
    a3.extend(a1[i:])
    a3.extend(a2[j:])
    return a3

merge_sort(array, 0, len(array)-1)

Efficiency of MErge Sort is O(N LogN)
------------------------------------------------
TREE:
A tree is a non-cyclic DS (acyclic)
A tree is heirarchical DS (Drives, folders and files in computer)
In tree data is stored in NODES
The only entry point of the tree is called as ROOT
A Node can have any number child nodes.
A node that is reached after traversing/descending a node (node reachable from a node)
The Root is said to be at a LEVEL 1.
The route we follow to reach the bottom of the tree from the ROOT is said to be PATH
Number of nodes we traverse in a path is said to be HEIGHT of the path.
The bottom of the path is said to be reached when there is no way to traverse any further. That is the present node has no child nodes.
Such a node is said to be LEAF node.
Heighest among the Heights of all the paths in the tree is the HEIGHT of the tree. In other words, highest of all possible levels in a tree is height of the tree.
If in a tree, every node has at most 2 child nodes, then the tree is BINARY TREE.
In a BT of height N, the maximum number of nodes is (2PowerN)-1 which is always a odd number.
The child node to the left of a node is LEFT CHILD NODE and on similar lines, we have RIGHT CHILD NODE.
A BT with exactly 2powerN-1 nodes is said to be COMPLETE BT.
A BT with all the nodes having only left child nodes or only right child nodes is actually a linear DS and is the BT having least number of nodes for given height H and will have H nodes in it.
A BT in which every node has exactly 0 or 2 child nodes only is said to be STRICTLY BT.
The height of a node in tree is the height from it to the far leaf node.
The tree that is obtained by traversing the left child node of the root is said to be LEFT SUB-TREE and thus we also have RIGHT SUB-TREE.
If in a BT, every node data is higher than its left child node data and is lesser than the right child data then such a BT is said to be BINARY SEARCH TREE.
NOTE: The nodes we can traverse from the current node itself constitutes into a BT and thus the current node itself can be considered as Root of such a tree.
If we traverse the BT such that we access the root 1st and the left child and then the right (R'LR) then it is said to be PRE-Order traversal
Aand the other 2 (only) traversals are LR'R and LRR'
Note that Left always comes before Right.
In a BST when we traverse in In-order, the data we get will be in ascending order.
If the BST is balanced which we call BBST then searching a node in it has efficiency of O(LogN) because with every traversal, we do aways with half of the BST (either the LST or RST)
BCE of searching an element in BST O(1)
WCE of searching an element in BST is O(n)
WCE of searching an element in BBST is O(LogN) which is nothing but Height of the BBST.
We always add the new node into a BST as Leaf node.



def add_node(root, new_node):
    if root == None:
        root = new_node
        return root
    temp1 = root
    temp2 = None
    while temp1 != None:
        temp2 = temp1
        if new_node.data < temp1.data:
            temp1 = temp1.left
        else:
            temp1 = temp1.right
    if new_node.data < temp2.data:
        temp2.left = new_node
    else:
        temp2.right = new_node
    return root


    
    
    Errors in python
Syntax error when it is not in the format.
Name error when it is not defined
Index error when the list element  is out of range.
Value error when we try to caste one value into another which is not possible for example file name can not be converted into the number so it is a value error.
Learn output formating on sreing and floatinh poit number.
Why in python we don't have increment and decrement.
Type error range expected atleat 3 arguments but they have given 4 arguments 
Zero division error occurs when the number can not be divided
map is used to access every element one by one in a list 
expansion : an instruction where it can not be exicuted in an expansion

draw.igo



Assignments:
__main and __learn
What Pythonic or pyp3
What is pythonic (range functions python)
Can we modify the list in a tuple 
Wants to pass a command line arguments into my_range()
Why and What argv stores the file name [0] and what is its purpose
Why in python there is no implicit type casting example abb+55 is a type error we can concatenate only string to a string not to an integer

Why there is no error in the case of Slicing 
Impliment a function which mimics a find method of a string class 
Accept a number from the user and find the next possible smallest number which is bigger than the given number having all the digits of the given number.

 
